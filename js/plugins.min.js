// ==ClosureCompiler==
// @compilation_level ADVANCED_OPTIMIZATIONS
// @externs_url http://closure-compiler.googlecode.com/svn/trunk/contrib/externs/maps/google_maps_api_v3.js
// @output_wrapper (function() {%output%})();
// ==/ClosureCompiler==
/**
 * @license
 * Copyright 2013 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * A RichMarker that allows any HTML/DOM to be added to a map and be draggable.
 *
 * @param {Object.<string, *>=} opt_options Optional properties to set.
 * @extends {google.maps.OverlayView}
 * @constructor
 */
function RichMarker(a){var b=a||{};/**
   * @type {boolean}
   * @private
   */
this.ready_=!1,/**
   * @type {boolean}
   * @private
   */
this.dragging_=!1,void 0==a.visible&&(a.visible=!0),void 0==a.shadow&&(a.shadow="7px -3px 5px rgba(88,88,88,0.7)"),void 0==a.anchor&&(a.anchor=RichMarkerPosition.BOTTOM),this.setValues(b)}!function(a,b){"use strict";function c(b,c,d){b._eventHandlers=b._eventHandlers||[// Creating new functions for one baron item only one time
{
// onScroll:
element:b.scroller,handler:function(a){b.scroll(a)},type:"scroll"},{
// css transitions & animations
element:b.root,handler:function(){b.update()},type:"transitionend animationend"},{
// onKeyup (textarea):
element:b.scroller,handler:function(){b.update()},type:"keyup"},{
// onMouseDown:
element:b.bar,handler:function(a){a.preventDefault(),// Text selection disabling in Opera... and all other browsers?
b.selection(),// Disable text selection in ie8
b.drag.now=1},type:"touchstart mousedown"},{
// onMouseUp:
element:document,handler:function(){b.selection(1),// Enable text selection
b.drag.now=0},type:"mouseup blur touchend"},{
// onCoordinateReset:
element:document,handler:function(a){2!=a.button&&// Not RM
b._pos0(a)},type:"touchstart mousedown"},{
// onMouseMove:
element:document,handler:function(a){b.drag.now&&b.drag(a)},type:"mousemove touchmove"},{
// onResize:
element:a,handler:function(){b.update()},type:"resize"},{
// sizeChange:
element:b.root,handler:function(){b.update()},type:"sizeChange"}],l(b._eventHandlers,function(a){a.element&&c(a.element,a.type,a.handler,d)})}function d(a,b,c){var d="data-baron-"+b;if("on"==c)a.setAttribute(d,"inited");else{if("off"!=c)return a.getAttribute(d);a.removeAttribute(d)}}function e(a){if(d(a.root,a.direction))throw new Error("Second baron initialization");var b=new n.prototype.constructor(a);// __proto__ of returning object is baron.prototype
return c(b,a.event,"on"),d(b.root,a.direction,"on"),b.update({initMode:!0}),b}function f(a){var b={};a=a||{};for(var c in a)a.hasOwnProperty(c)&&(b[c]=a[c]);return b}function g(a){var b=f(a);b.direction=b.direction||"v";var c=a.event||function(a,c,d,e){b.$(a)[e||"on"](c,d)};return b.event=function(a,b,d,e){l(a,function(a){c(a,b,d,e)})},b}function h(a){/* jshint validthis:true */
if(this.events&&this.events[a])for(var b=0;b<this.events[a].length;b++){var c=Array.prototype.slice.call(arguments,1);this.events[a][b].apply(this,c)}}if(a){// Server side
var i=m,// Stored baron value for noConflict usage
j=["left","top","right","bottom","width","height"],k={v:{// Vertical
x:"Y",pos:j[1],oppos:j[3],crossPos:j[0],crossOpPos:j[2],size:j[5],crossSize:j[4],client:"clientHeight",crossClient:"clientWidth",crossScroll:"scrollWidth",offset:"offsetHeight",crossOffset:"offsetWidth",offsetPos:"offsetTop",scroll:"scrollTop",scrollSize:"scrollHeight"},h:{// Horizontal
x:"X",pos:j[0],oppos:j[2],crossPos:j[1],crossOpPos:j[3],size:j[4],crossSize:j[5],client:"clientWidth",crossClient:"clientHeight",crossScroll:"scrollHeight",offset:"offsetWidth",crossOffset:"offsetHeight",offsetPos:"offsetLeft",scroll:"scrollLeft",scrollSize:"scrollWidth"}},l=function(b,c){var d=0;for(void 0!==b.length&&b!==a||(b=[b]);b[d];)c.call(this,b[d],d),d++},m=function(b){var c,d,e;// this - window or jQuery instance
return b=b||{},e=b.$||a.jQuery,c=this instanceof e,c?b.root=d=this:d=e(b.root||b.scroller),new m.fn.constructor(d,b,e).autoUpdate()};m.fn={constructor:function(a,b,c){var d=g(b);d.$=c,l.call(this,a,function(a,b){var c=f(d);d.root&&d.scroller?(c.scroller=d.$(d.scroller,a),c.scroller.length||(c.scroller=a)):c.scroller=a,c.root=a,this[b]=e(c),this.length=b+1}),this.params=d},dispose:function(){var a=this.params;this[0]&&/* Если есть хотя бы 1 рабочий инстанс */
l(this,function(b){b.dispose(a)}),this.params=null},update:function(){for(var a=0;this[a];)this[a].update.apply(this[a],arguments),a++},baron:function(a){return a.root=[],a.scroller=this.params.scroller,l.call(this,this,function(b){a.root.push(b.root)}),a.direction="v"==this.params.direction?"h":"v",a._chain=!0,m(a)}};var n={};n.prototype={constructor:function(a){function b(a,b){return j(a,b)[0]}
// Updating height or width of bar
function c(a){/* jshint validthis:true */
var b=this.barMinSize||20;a>0&&a<b&&(a=b),this.bar&&j(this.bar).css(this.origin.size,parseInt(a,10)+"px")}
// Updating top or left bar position
function d(a){/* jshint validthis:true */
this.bar&&j(this.bar).css(this.origin.pos,+a+"px")}
// Free path for bar
function e(){/* jshint validthis:true */
return n[this.origin.client]-this.barTopLimit-this.bar[this.origin.offset]}
// Relative content top position to bar top position
function f(a){/* jshint validthis:true */
return a*e.call(this)+this.barTopLimit}
// Bar position to relative content position
function g(a){/* jshint validthis:true */
return(a-this.barTopLimit)/e.call(this)}
// Text selection pos preventing
function i(){return!1}var j,l,m,n,o,p,q,r,s,t,u;
// DOM elements
// Always html node, not just selector
// (params.scroller) ? getNode(params.scroller, this.root) : this.root;
// Parameters
// Cursor position in main direction in px // Now with iOs support
// Switch on the bar by adding user-defined CSS classname to scroller
// Text selection preventing on drag
// onResize & DOM modified handler
// onScroll handler
return t=s=(new Date).getTime(),j=this.$=a.$,this.event=a.event,this.events={},this.root=a.root,this.scroller=b(a.scroller),this.bar=b(a.bar,this.root),n=this.track=b(a.track,this.root),!this.track&&this.bar&&(n=this.bar.parentNode),this.clipper=this.scroller.parentNode,this.direction=a.direction,this.origin=k[this.direction],this.barOnCls=a.barOnCls,this.scrollingCls=a.scrollingCls,this.barTopLimit=0,r=1e3*a.pause||0,this.cursor=function(a){return a["client"+this.origin.x]||(((a.originalEvent||a).touches||{})[0]||{})["page"+this.origin.x]},this.pos=function(a){// Absolute scroller position in px
var b="page"+this.origin.x+"Offset",c=this.scroller[b]?b:this.origin.scroll;return void 0!==a&&(this.scroller[c]=a),this.scroller[c]},this.rpos=function(a){// Relative scroller position (0..1)
var b=this.scroller[this.origin.scrollSize]-this.scroller[this.origin.client];return(a?this.pos(a*b):this.pos())/(b||1)},this.barOn=function(a){this.barOnCls&&(a||this.scroller[this.origin.client]>=this.scroller[this.origin.scrollSize]?j(this.root).removeClass(this.barOnCls):j(this.root).addClass(this.barOnCls))},this._pos0=function(a){m=this.cursor(a)-l},this.drag=function(a){this.scroller[this.origin.scroll]=g.call(this,this.cursor(a)-m)*(this.scroller[this.origin.scrollSize]-this.scroller[this.origin.client])},this.selection=function(a){this.event(document,"selectpos selectstart",i,a?"off":"on")},this.resize=function(){function b(){var b,d;c.barOn(),d=c.scroller[c.origin.crossClient],b=c.scroller[c.origin.crossOffset]-d,a.freeze&&!c.clipper.style[c.origin.crossSize]&&// Sould fire only once
j(c.clipper).css(c.origin.crossSize,c.clipper[c.origin.crossClient]-b+"px"),j(c.scroller).css(c.origin.crossSize,c.clipper[c.origin.crossClient]+b+"px"),Array.prototype.unshift.call(arguments,"resize"),h.apply(c,arguments),t=(new Date).getTime()}var c=this,d=0;(new Date).getTime()-t<r&&(clearTimeout(o),d=r),d?o=setTimeout(b,d):b()},this.updatePositions=function(){var a,b=this;b.bar&&(a=(n[b.origin.client]-b.barTopLimit)*b.scroller[b.origin.client]/b.scroller[b.origin.scrollSize],
// Positioning bar
parseInt(u,10)!=parseInt(a,10)&&(c.call(b,a),u=a),l=f.call(b,b.rpos()),d.call(b,l)),Array.prototype.unshift.call(arguments,"scroll"),h.apply(b,arguments),s=(new Date).getTime()},this.scroll=function(){var a=0,b=this;(new Date).getTime()-s<r&&(clearTimeout(p),a=r),(new Date).getTime()-s<r&&(clearTimeout(p),a=r),a?p=setTimeout(function(){b.updatePositions()},a):b.updatePositions(),b.scrollingCls&&(q||this.$(this.scroller).addClass(this.scrollingCls),clearTimeout(q),q=setTimeout(function(){b.$(b.scroller).removeClass(b.scrollingCls),q=void 0},300))},this},update:function(a){// Update all plugins' params
return h.call(this,"upd",a),this.resize(1),this.updatePositions(),this},dispose:function(a){c(this,this.event,"off"),d(this.root,a.direction,"off"),$(this.scroller).css(this.origin.crossSize,""),this.barOn(!0),h.call(this,"dispose")},on:function(a,b,c){for(var d=a.split(" "),e=0;e<d.length;e++)"init"==d[e]?b.call(this,c):(this.events[d[e]]=this.events[d[e]]||[],this.events[d[e]].push(function(a){b.call(this,a||c)}))}},m.fn.constructor.prototype=m.fn,n.prototype.constructor.prototype=n.prototype,
// Use when you need "baron" global var for another purposes
m.noConflict=function(){// Restoring original value of "baron" global var
return a.baron=i,m},m.version="0.7.7",a.$&&$.fn&&(// Adding baron to jQuery as plugin
$.fn.baron=m),a.baron=m,// Use noConflict method if you need window.baron var for another purposes
a.module&&module.exports&&(module.exports=m.noConflict())}}(window),/* Fixable elements plugin for baron 0.6+ */
function(a,b){var c=function(a){
// i - number of fixing element, pos - fix-position in px, flag - 1: top, 2: bottom
// Invocation only in case when fix-state changed
function c(a,c,d){var e=1==d?"pos":"oppos";g<(h.minView||0)&&(// No headers fixing when no enought space for viewport
c=b),
// Removing all fixing stuff - we can do this because fixElement triggers only when fixState really changed
this.$(f[a]).css(this.origin.pos,"").css(this.origin.oppos,"").removeClass(h.outside),
// Fixing if needed
c!==b&&(c+="px",this.$(f[a]).css(this.origin[e],c).addClass(h.outside))}function d(a){try{i=document.createEvent("WheelEvent"),// i - for extra byte
// evt.initWebKitWheelEvent(deltaX, deltaY, window, screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey);
i.initWebKitWheelEvent(a.originalEvent.wheelDeltaX,a.originalEvent.wheelDeltaY),m.dispatchEvent(i),a.preventDefault()}catch(a){}}function e(a){var b;for(var c in a)h[c]=a[c];if(f=this.$(h.elements,this.scroller)){g=this.scroller[this.origin.client];for(var e=0;e<f.length;e++)
// Variable header heights
b={},b[this.origin.size]=f[e][this.origin.offset],f[e].parentNode!==this.scroller&&this.$(f[e].parentNode).css(b),b={},b[this.origin.crossSize]=f[e].parentNode[this.origin.crossClient],this.$(f[e]).css(b),
// Between fixed headers
g-=f[e][this.origin.offset],l[e]=f[e].parentNode[this.origin.offsetPos],// No paddings for parentNode
// Summary elements height above current
j[e]=j[e-1]||0,// Not zero because of negative margins
k[e]=k[e-1]||Math.min(l[e],0),f[e-1]&&(j[e]+=f[e-1][this.origin.offset],k[e]+=f[e-1][this.origin.offset]),0==e&&0==l[e]||(this.event(f[e],"mousewheel",d,"off"),this.event(f[e],"mousewheel",d));h.limiter&&f[0]&&(// Bottom edge of first header as top limit for track
this.track&&this.track!=this.scroller?(b={},b[this.origin.pos]=f[0].parentNode[this.origin.offset],this.$(this.track).css(b)):this.barTopLimit=f[0].parentNode[this.origin.offset],
// this.barTopLimit = elements[0].parentNode[this.origin.offset];
this.scroll()),h.limiter===!1&&(// undefined (in second fix instance) should have no influence on bar limit
this.barTopLimit=0)}var i={element:f,handler:function(){
// finding num -> elements[num] === this
for(var a,b=o(this)[0].parentNode,c=b.offsetTop,d=0;d<f.length;d++)f[d]===this&&(a=d);var e=c-j[a];h.scroll?// User defined callback
h.scroll({x1:p.scroller.scrollTop,x2:e}):p.scroller.scrollTop=e},type:"click"};h.clickable&&(this._eventHandlers.push(i),// For auto-dispose
// eventManager(event.element, event.type, event.handler, 'off');
n(i.element,i.type,i.handler,"on"))}var f,g,h={// Default params
outside:"",inside:"",before:"",after:"",past:"",future:"",radius:0,minView:0},j=[],// inline style for element
k=[],// ? something related to negative margins for fixable elements
l=[],// offset positions when not fixed
m=this.scroller,n=this.event,o=this.$,p=this;this.on("init",e,a);var q=[],// 1 - past, 2 - future, 3 - current (not fixed)
r=[];this.on("init scroll",function(){var a,d,e;if(f){
// fixFlag update
for(var i,m=0;m<f.length;m++)a=0,l[m]-this.pos()<k[m]+h.radius?(
// Header trying to go up
a=1,d=j[m]):l[m]-this.pos()>k[m]+g-h.radius?(
// Header trying to go down
a=2,
// console.log('topFixHeights[i] + viewPortSize + topRealHeights[i]', topFixHeights[i], this.scroller[this.origin.client], topRealHeights[i]);
d=this.scroller[this.origin.client]-f[m][this.origin.offset]-j[m]-g):(
// Header in viewport
a=3,d=b),e=!1,(l[m]-this.pos()<k[m]||l[m]-this.pos()>k[m]+g)&&(e=!0),a==q[m]&&e==r[m]||(c.call(this,m,d,a),q[m]=a,r[m]=e,i=!0);
// Adding positioning classes (on last top and first bottom header)
if(i)// At leats one change in elements flag structure occured
for(m=0;m<f.length;m++)1==q[m]&&h.past&&this.$(f[m]).addClass(h.past).removeClass(h.future),2==q[m]&&h.future&&this.$(f[m]).addClass(h.future).removeClass(h.past),3==q[m]?((h.future||h.past)&&this.$(f[m]).removeClass(h.past).removeClass(h.future),h.inside&&this.$(f[m]).addClass(h.inside)):h.inside&&this.$(f[m]).removeClass(h.inside),q[m]!=q[m+1]&&1==q[m]&&h.before?this.$(f[m]).addClass(h.before).removeClass(h.after):q[m]!=q[m-1]&&2==q[m]&&h.after?this.$(f[m]).addClass(h.after).removeClass(h.before):this.$(f[m]).removeClass(h.before).removeClass(h.after),h.grad&&(r[m]?this.$(f[m]).addClass(h.grad):this.$(f[m]).removeClass(h.grad))}}),this.on("resize upd",function(a){e.call(this,a&&a.fix)})};baron.fn.fix=function(a){for(var b=0;this[b];)c.call(this[b],a),b++;return this}}(window),/* Controls plugin for baron 0.6+ */
function(a,b){var c=function(a){var b,c,d,e,// AAAAAA!!!!!11
f,g=this;e=a.screen||.9,a.forward&&(b=this.$(a.forward,this.clipper),f={element:b,handler:function(){var b=g.pos()-a.delta||30;g.pos(b)},type:"click"},this._eventHandlers.push(f),// For auto-dispose
this.event(f.element,f.type,f.handler,"on")),a.backward&&(c=this.$(a.backward,this.clipper),f={element:c,handler:function(){var b=g.pos()+a.delta||30;g.pos(b)},type:"click"},this._eventHandlers.push(f),// For auto-dispose
this.event(f.element,f.type,f.handler,"on")),a.track&&(d=a.track===!0?this.track:this.$(a.track,this.clipper)[0])&&(f={element:d,handler:function(a){var b=a["offset"+g.origin.x],c=g.bar[g.origin.offsetPos],d=0;b<c?d=-1:b>c+g.bar[g.origin.offset]&&(d=1);var f=g.pos()+d*e*g.scroller[g.origin.client];g.pos(f)},type:"mousedown"},this._eventHandlers.push(f),// For auto-dispose
this.event(f.element,f.type,f.handler,"on"))};baron.fn.controls=function(a){for(var b=0;this[b];)c.call(this[b],a),b++;return this}}(window),/* Pull to load plugin for baron 0.6+ */
function(a,b){var c=function(a){function b(){return r.scroller[r.origin.scroll]+r.scroller[r.origin.offset]}
// Scroller content height
function c(){return r.scroller[r.origin.scrollSize]}
// Scroller height
function d(){return r.scroller[r.origin.client]}function e(a,b){var c=5e-4*a;return Math.floor(b-c*(a+550))}function f(a){k=a,a?(g(),// First time with no delay
h=setInterval(g,200)):clearInterval(h)}function g(){var g,h,k={},w=b(),x=c(),y=1==s;if(h=0,// Возвращающая сила
s>0&&(h=40),
//if (_insistence > -1) {
g=e(u,h),w>=x-u&&s>-1?y&&(u+=g):u=0,u<0&&(u=0),k[m]=u+"px",d()<=c()){r.$(l).css(k);for(var z=0;z<p.length;z++)r.$(p[z].self).css(p[z].property,Math.min(u/n*100,100)+"%")}q&&u&&r.$(r.root).addClass(q),0==u&&a.onCollapse&&a.onCollapse(),s=0,i=setTimeout(function(){s=-1},v),
//}
o&&u>n&&!j&&(o(),j=!0),0==u?t++:t=0,t>1&&(f(!1),j=!1,q&&r.$(r.root).removeClass(q))}var h,i,j,k,l=this.$(a.block),m=a.size||this.origin.size,n=a.limit||80,o=a.onExpand,p=a.elements||[],q=a.inProgress||"",r=this,s=0,t=0,u=0,v=a.waiting||500;this.on("init",function(){f(!0)}),this.on("dispose",function(){f(!1)}),this.event(this.scroller,"mousewheel DOMMouseScroll",function(a){(a.wheelDelta<0||a.originalEvent&&a.originalEvent.wheelDelta<0||a.detail>0)&&(s=1,clearTimeout(i),!k&&b()>=c()&&f(!0))})};baron.fn.pull=function(a){for(var b=0;this[b];)c.call(this[b],a),b++;return this}}(window),/* Autoupdate plugin for baron 0.6+ */
function(a,b){var c=a.MutationObserver||a.WebKitMutationObserver||a.MozMutationObserver||null,d=function(){var a=this;this._observer=new c(function(){a.update()}),this.on("init",function(){a._observer.observe(a.root,{childList:!0,subtree:!0,characterData:!0})}),this.on("dispose",function(){a._observer.disconnect(),delete a._observer})};baron.fn.autoUpdate=function(a){if(!c)return this;for(var b=0;this[b];)d.call(this[b],a),b++;return this}}(window),/*!
 * jQuery throttle / debounce - v1.1 - 3/7/2010
 * http://benalman.com/projects/jquery-throttle-debounce-plugin/
 * 
 * Copyright (c) 2010 "Cowboy" Ben Alman
 * Dual licensed under the MIT and GPL licenses.
 * http://benalman.com/about/license/
 */
// Script: jQuery throttle / debounce: Sometimes, less is more!
//
// *Version: 1.1, Last updated: 3/7/2010*
// 
// Project Home - http://benalman.com/projects/jquery-throttle-debounce-plugin/
// GitHub       - http://github.com/cowboy/jquery-throttle-debounce/
// Source       - http://github.com/cowboy/jquery-throttle-debounce/raw/master/jquery.ba-throttle-debounce.js
// (Minified)   - http://github.com/cowboy/jquery-throttle-debounce/raw/master/jquery.ba-throttle-debounce.min.js (0.7kb)
// 
// About: License
// 
// Copyright (c) 2010 "Cowboy" Ben Alman,
// Dual licensed under the MIT and GPL licenses.
// http://benalman.com/about/license/
// 
// About: Examples
// 
// These working examples, complete with fully commented code, illustrate a few
// ways in which this plugin can be used.
// 
// Throttle - http://benalman.com/code/projects/jquery-throttle-debounce/examples/throttle/
// Debounce - http://benalman.com/code/projects/jquery-throttle-debounce/examples/debounce/
// 
// About: Support and Testing
// 
// Information about what version or versions of jQuery this plugin has been
// tested with, what browsers it has been tested in, and where the unit tests
// reside (so you can test it yourself).
// 
// jQuery Versions - none, 1.3.2, 1.4.2
// Browsers Tested - Internet Explorer 6-8, Firefox 2-3.6, Safari 3-4, Chrome 4-5, Opera 9.6-10.1.
// Unit Tests      - http://benalman.com/code/projects/jquery-throttle-debounce/unit/
// 
// About: Release History
// 
// 1.1 - (3/7/2010) Fixed a bug in <jQuery.throttle> where trailing callbacks
//       executed later than they should. Reworked a fair amount of internal
//       logic as well.
// 1.0 - (3/6/2010) Initial release as a stand-alone project. Migrated over
//       from jquery-misc repo v0.4 to jquery-throttle repo v1.0, added the
//       no_trailing throttle parameter and debounce functionality.
// 
// Topic: Note for non-jQuery users
// 
// jQuery isn't actually required for this plugin, because nothing internal
// uses any jQuery methods or properties. jQuery is just used as a namespace
// under which these methods can exist.
// 
// Since jQuery isn't actually required for this plugin, if jQuery doesn't exist
// when this plugin is loaded, the method described below will be created in
// the `Cowboy` namespace. Usage will be exactly the same, but instead of
// $.method() or jQuery.method(), you'll need to use Cowboy.method().
function(a,b){"$:nomunge";// Used by YUI compressor.
// Since jQuery really isn't required for this plugin, use `jQuery` as the
// namespace only if it already exists, otherwise use the `Cowboy` namespace,
// creating it if necessary.
var
// Internal method reference.
c,d=a.jQuery||a.Cowboy||(a.Cowboy={});
// Method: jQuery.throttle
// 
// Throttle execution of a function. Especially useful for rate limiting
// execution of handlers on events like resize and scroll. If you want to
// rate-limit execution of a function to a single time, see the
// <jQuery.debounce> method.
// 
// In this visualization, | is a throttled-function call and X is the actual
// callback execution:
// 
// > Throttled with `no_trailing` specified as false or unspecified:
// > ||||||||||||||||||||||||| (pause) |||||||||||||||||||||||||
// > X    X    X    X    X    X        X    X    X    X    X    X
// > 
// > Throttled with `no_trailing` specified as true:
// > ||||||||||||||||||||||||| (pause) |||||||||||||||||||||||||
// > X    X    X    X    X             X    X    X    X    X
// 
// Usage:
// 
// > var throttled = jQuery.throttle( delay, [ no_trailing, ] callback );
// > 
// > jQuery('selector').bind( 'someevent', throttled );
// > jQuery('selector').unbind( 'someevent', throttled );
// 
// This also works in jQuery 1.4+:
// 
// > jQuery('selector').bind( 'someevent', jQuery.throttle( delay, [ no_trailing, ] callback ) );
// > jQuery('selector').unbind( 'someevent', callback );
// 
// Arguments:
// 
//  delay - (Number) A zero-or-greater delay in milliseconds. For event
//    callbacks, values around 100 or 250 (or even higher) are most useful.
//  no_trailing - (Boolean) Optional, defaults to false. If no_trailing is
//    true, callback will only execute every `delay` milliseconds while the
//    throttled-function is being called. If no_trailing is false or
//    unspecified, callback will be executed one final time after the last
//    throttled-function call. (After the throttled-function has not been
//    called for `delay` milliseconds, the internal counter is reset)
//  callback - (Function) A function to be executed after delay milliseconds.
//    The `this` context and all arguments are passed through, as-is, to
//    `callback` when the throttled-function is executed.
// 
// Returns:
// 
//  (Function) A new, throttled, function.
d.throttle=c=function(a,c,e,f){
// The `wrapper` function encapsulates all of the throttling / debouncing
// functionality and when executed will limit the rate at which `callback`
// is executed.
function g(){
// Execute `callback` and update the `last_exec` timestamp.
function d(){i=+new Date,e.apply(j,l)}
// If `debounce_mode` is true (at_begin) this is used to clear the flag
// to allow future `callback` executions.
function g(){h=b}var j=this,k=+new Date-i,l=arguments;f&&!h&&
// Since `wrapper` is being called for the first time and
// `debounce_mode` is true (at_begin), execute `callback`.
d(),
// Clear any existing timeout.
h&&clearTimeout(h),f===b&&k>a?
// In throttle mode, if `delay` time has been exceeded, execute
// `callback`.
d():c!==!0&&(
// In trailing throttle mode, since `delay` time has not been
// exceeded, schedule `callback` to execute `delay` ms after most
// recent execution.
// 
// If `debounce_mode` is true (at_begin), schedule `clear` to execute
// after `delay` ms.
// 
// If `debounce_mode` is false (at end), schedule `callback` to
// execute after `delay` ms.
h=setTimeout(f?g:d,f===b?a-k:a))}
// After wrapper has stopped being called, this timeout ensures that
// `callback` is executed at the proper times in `throttle` and `end`
// debounce modes.
var h,
// Keep track of the last time `callback` was executed.
i=0;
// Return the wrapper function.
// `no_trailing` defaults to falsy.
// Set the guid of `wrapper` function to the same of original callback, so
// it can be removed in jQuery 1.4+ .unbind or .die by using the original
// callback as a reference.
return"boolean"!=typeof c&&(f=e,e=c,c=b),d.guid&&(g.guid=e.guid=e.guid||d.guid++),g},
// Method: jQuery.debounce
// 
// Debounce execution of a function. Debouncing, unlike throttling,
// guarantees that a function is only executed a single time, either at the
// very beginning of a series of calls, or at the very end. If you want to
// simply rate-limit execution of a function, see the <jQuery.throttle>
// method.
// 
// In this visualization, | is a debounced-function call and X is the actual
// callback execution:
// 
// > Debounced with `at_begin` specified as false or unspecified:
// > ||||||||||||||||||||||||| (pause) |||||||||||||||||||||||||
// >                          X                                 X
// > 
// > Debounced with `at_begin` specified as true:
// > ||||||||||||||||||||||||| (pause) |||||||||||||||||||||||||
// > X                                 X
// 
// Usage:
// 
// > var debounced = jQuery.debounce( delay, [ at_begin, ] callback );
// > 
// > jQuery('selector').bind( 'someevent', debounced );
// > jQuery('selector').unbind( 'someevent', debounced );
// 
// This also works in jQuery 1.4+:
// 
// > jQuery('selector').bind( 'someevent', jQuery.debounce( delay, [ at_begin, ] callback ) );
// > jQuery('selector').unbind( 'someevent', callback );
// 
// Arguments:
// 
//  delay - (Number) A zero-or-greater delay in milliseconds. For event
//    callbacks, values around 100 or 250 (or even higher) are most useful.
//  at_begin - (Boolean) Optional, defaults to false. If at_begin is false or
//    unspecified, callback will only be executed `delay` milliseconds after
//    the last debounced-function call. If at_begin is true, callback will be
//    executed only at the first debounced-function call. (After the
//    throttled-function has not been called for `delay` milliseconds, the
//    internal counter is reset)
//  callback - (Function) A function to be executed after delay milliseconds.
//    The `this` context and all arguments are passed through, as-is, to
//    `callback` when the debounced-function is executed.
// 
// Returns:
// 
//  (Function) A new, debounced, function.
d.debounce=function(a,d,e){return e===b?c(a,d,!1):c(a,e,d!==!1)}}(this),function(a){var b={},c={
// GENERAL
mode:"horizontal",slideSelector:"",infiniteLoop:!0,hideControlOnEnd:!1,speed:500,easing:null,slideMargin:0,startSlide:0,randomStart:!1,captions:!1,ticker:!1,tickerHover:!1,adaptiveHeight:!1,adaptiveHeightSpeed:500,video:!1,useCSS:!0,preloadImages:"visible",responsive:!0,slideZIndex:50,wrapperClass:"bx-wrapper",
// TOUCH
touchEnabled:!0,swipeThreshold:50,oneToOneTouch:!0,preventDefaultSwipeX:!0,preventDefaultSwipeY:!1,
// PAGER
pager:!0,pagerType:"full",pagerShortSeparator:" / ",pagerSelector:null,buildPager:null,pagerCustom:null,
// CONTROLS
controls:!0,nextText:"Next",prevText:"Prev",nextSelector:null,prevSelector:null,autoControls:!1,startText:"Start",stopText:"Stop",autoControlsCombine:!1,autoControlsSelector:null,
// AUTO
auto:!1,pause:4e3,autoStart:!0,autoDirection:"next",autoHover:!1,autoDelay:0,autoSlideForOnePage:!1,
// CAROUSEL
minSlides:1,maxSlides:1,moveSlides:0,slideWidth:0,
// CALLBACKS
onSliderLoad:function(){},onSlideBefore:function(){},onSlideAfter:function(){},onSlideNext:function(){},onSlidePrev:function(){},onSliderResize:function(){}};a.fn.bxSlider=function(d){if(0==this.length)return this;
// support mutltiple elements
if(this.length>1)return this.each(function(){a(this).bxSlider(d)}),this;
// create a namespace to be used throughout the plugin
var e={},f=this;b.el=this;/**
		 * Makes slideshow responsive
		 */
// first get the original window dimens (thanks alot IE)
var g=a(window).width(),h=a(window).height(),j=function(){
// merge user-supplied options with the defaults
e.settings=a.extend({},c,d),
// parse slideWidth setting
e.settings.slideWidth=parseInt(e.settings.slideWidth),
// store the original children
e.children=f.children(e.settings.slideSelector),
// check if actual number of slides is less than minSlides / maxSlides
e.children.length<e.settings.minSlides&&(e.settings.minSlides=e.children.length),e.children.length<e.settings.maxSlides&&(e.settings.maxSlides=e.children.length),
// if random start, set the startSlide setting to random number
e.settings.randomStart&&(e.settings.startSlide=Math.floor(Math.random()*e.children.length)),
// store active slide information
e.active={index:e.settings.startSlide},
// store if the slider is in carousel mode (displaying / moving multiple slides)
e.carousel=e.settings.minSlides>1||e.settings.maxSlides>1,
// if carousel, force preloadImages = 'all'
e.carousel&&(e.settings.preloadImages="all"),
// calculate the min / max width thresholds based on min / max number of slides
// used to setup and update carousel slides dimensions
e.minThreshold=e.settings.minSlides*e.settings.slideWidth+(e.settings.minSlides-1)*e.settings.slideMargin,e.maxThreshold=e.settings.maxSlides*e.settings.slideWidth+(e.settings.maxSlides-1)*e.settings.slideMargin,
// store the current state of the slider (if currently animating, working is true)
e.working=!1,
// initialize the controls object
e.controls={},
// initialize an auto interval
e.interval=null,
// determine which property to use for transitions
e.animProp="vertical"==e.settings.mode?"top":"left",
// determine if hardware acceleration can be used
e.usingCSS=e.settings.useCSS&&"fade"!=e.settings.mode&&function(){
// create our test div element
var a=document.createElement("div"),b=["WebkitPerspective","MozPerspective","OPerspective","msPerspective"];
// test for each property
for(var c in b)if(void 0!==a.style[b[c]])return e.cssPrefix=b[c].replace("Perspective","").toLowerCase(),e.animProp="-"+e.cssPrefix+"-transform",!0;return!1}(),
// if vertical mode always make maxSlides and minSlides equal
"vertical"==e.settings.mode&&(e.settings.maxSlides=e.settings.minSlides),
// save original style data
f.data("origStyle",f.attr("style")),f.children(e.settings.slideSelector).each(function(){a(this).data("origStyle",a(this).attr("style"))}),
// perform all DOM / CSS modifications
k()},k=function(){
// wrap el in a wrapper
f.wrap('<div class="'+e.settings.wrapperClass+'"><div class="bx-viewport"></div></div>'),
// store a namspace reference to .bx-viewport
e.viewport=f.parent(),
// add a loading div to display while images are loading
e.loader=a('<div class="bx-loading" />'),e.viewport.prepend(e.loader),
// set el to a massive width, to hold any needed slides
// also strip any margin and padding from el
f.css({width:"horizontal"==e.settings.mode?100*e.children.length+215+"%":"auto",position:"relative"}),
// if using CSS, add the easing property
e.usingCSS&&e.settings.easing?f.css("-"+e.cssPrefix+"-transition-timing-function",e.settings.easing):e.settings.easing||(e.settings.easing="swing");q();
// make modifications to the viewport (.bx-viewport)
e.viewport.css({width:"100%",overflow:"hidden",position:"relative"}),e.viewport.parent().css({maxWidth:o()}),
// make modification to the wrapper (.bx-wrapper)
e.settings.pager||e.viewport.parent().css({margin:"0 auto 0px"}),
// apply css to all slider children
e.children.css({float:"horizontal"==e.settings.mode?"left":"none",listStyle:"none",position:"relative"}),
// apply the calculated width after the float is applied to prevent scrollbar interference
e.children.css("width",p()),
// if slideMargin is supplied, add the css
"horizontal"==e.settings.mode&&e.settings.slideMargin>0&&e.children.css("marginRight",e.settings.slideMargin),"vertical"==e.settings.mode&&e.settings.slideMargin>0&&e.children.css("marginBottom",e.settings.slideMargin),
// if "fade" mode, add positioning and z-index CSS
"fade"==e.settings.mode&&(e.children.css({position:"absolute",zIndex:0,display:"none"}),
// prepare the z-index on the showing element
e.children.eq(e.settings.startSlide).css({zIndex:e.settings.slideZIndex,display:"block"})),
// create an element to contain all slider controls (pager, start / stop, etc)
e.controls.el=a('<div class="bx-controls" />'),
// if captions are requested, add them
e.settings.captions&&z(),
// check if startSlide is last slide
e.active.last=e.settings.startSlide==r()-1,
// if video is true, set up the fitVids plugin
e.settings.video&&f.fitVids();
// set the default preload selector (visible)
var b=e.children.eq(e.settings.startSlide);"all"==e.settings.preloadImages&&(b=e.children),
// only check for control addition if not in "ticker" mode
e.settings.ticker?e.settings.pager=!1:(
// if pager is requested, add it
e.settings.pager&&w(),
// if controls are requested, add them
e.settings.controls&&x(),
// if auto is true, and auto controls are requested, add them
e.settings.auto&&e.settings.autoControls&&y(),
// if any control option is requested, add the controls wrapper
(e.settings.controls||e.settings.autoControls||e.settings.pager)&&e.viewport.after(e.controls.el)),
// preload all images, then perform final DOM / CSS modifications that depend on images being loaded
l(b,m)},l=function(b,c){var d=b.find("img, iframe").length;if(0==d)return void c();var e=0;b.find("img, iframe").each(function(){a(this).one("load",function(){++e==d&&c()}).each(function(){this.complete&&a(this).load()})})},m=function(){
// if infinite loop, prepare additional slides
if(e.settings.infiniteLoop&&"fade"!=e.settings.mode&&!e.settings.ticker){var b="vertical"==e.settings.mode?e.settings.minSlides:e.settings.maxSlides,c=e.children.slice(0,b).clone().addClass("bx-clone"),d=e.children.slice(-b).clone().addClass("bx-clone");f.append(c).prepend(d)}
// remove the loading DOM element
e.loader.remove(),
// set the left / top position of "el"
t(),
// if "vertical" mode, always use adaptiveHeight to prevent odd behavior
"vertical"==e.settings.mode&&(e.settings.adaptiveHeight=!0),
// set the viewport height
e.viewport.height(n()),
// make sure everything is positioned just right (same as a window resize)
f.redrawSlider(),
// onSliderLoad callback
e.settings.onSliderLoad(e.active.index),
// slider has been fully initialized
e.initialized=!0,
// bind the resize call to the window
e.settings.responsive&&a(window).bind("resize",Q),
// if auto is true and has more than 1 page, start the show
e.settings.auto&&e.settings.autoStart&&(r()>1||e.settings.autoSlideForOnePage)&&J(),
// if ticker is true, start the ticker
e.settings.ticker&&K(),
// if pager is requested, make the appropriate pager link active
e.settings.pager&&F(e.settings.startSlide),
// check for any updates to the controls (like hideControlOnEnd updates)
e.settings.controls&&I(),
// if touchEnabled is true, setup the touch events
e.settings.touchEnabled&&!e.settings.ticker&&M()},n=function(){var b=0,c=a();
// if mode is not "vertical" and adaptiveHeight is false, include all children
if("vertical"==e.settings.mode||e.settings.adaptiveHeight)
// if not carousel, return the single active child
if(e.carousel){
// get the individual slide index
var d=1==e.settings.moveSlides?e.active.index:e.active.index*s();
// cycle through the remaining "showing" slides
for(
// add the current slide to the children
c=e.children.eq(d),i=1;i<=e.settings.maxSlides-1;i++)
// if looped back to the start
c=d+i>=e.children.length?c.add(e.children.eq(i-1)):c.add(e.children.eq(d+i))}else c=e.children.eq(e.active.index);else c=e.children;
// if "vertical" mode, calculate the sum of the heights of the children
// add user-supplied margins
return"vertical"==e.settings.mode?(c.each(function(c){b+=a(this).outerHeight()}),e.settings.slideMargin>0&&(b+=e.settings.slideMargin*(e.settings.minSlides-1))):b=Math.max.apply(Math,c.map(function(){return a(this).outerHeight(!1)}).get()),"border-box"==e.viewport.css("box-sizing")?b+=parseFloat(e.viewport.css("padding-top"))+parseFloat(e.viewport.css("padding-bottom"))+parseFloat(e.viewport.css("border-top-width"))+parseFloat(e.viewport.css("border-bottom-width")):"padding-box"==e.viewport.css("box-sizing")&&(b+=parseFloat(e.viewport.css("padding-top"))+parseFloat(e.viewport.css("padding-bottom"))),b},o=function(){var a="100%";return e.settings.slideWidth>0&&(a="horizontal"==e.settings.mode?e.settings.maxSlides*e.settings.slideWidth+(e.settings.maxSlides-1)*e.settings.slideMargin:e.settings.slideWidth),a},p=function(){
// start with any user-supplied slide width
var a=e.settings.slideWidth,b=e.viewport.width();
// if slide width was not supplied, or is larger than the viewport use the viewport width
return 0==e.settings.slideWidth||e.settings.slideWidth>b&&!e.carousel||"vertical"==e.settings.mode?a=b:e.settings.maxSlides>1&&"horizontal"==e.settings.mode&&(b>e.maxThreshold||b<e.minThreshold&&(a=(b-e.settings.slideMargin*(e.settings.minSlides-1))/e.settings.minSlides)),a},q=function(){var a=1;if("horizontal"==e.settings.mode&&e.settings.slideWidth>0)
// if viewport is smaller than minThreshold, return minSlides
if(e.viewport.width()<e.minThreshold)a=e.settings.minSlides;else if(e.viewport.width()>e.maxThreshold)a=e.settings.maxSlides;else{var b=e.children.first().width()+e.settings.slideMargin;a=Math.floor((e.viewport.width()+e.settings.slideMargin)/b)}else"vertical"==e.settings.mode&&(a=e.settings.minSlides);return a},r=function(){var a=0;
// if moveSlides is specified by the user
if(e.settings.moveSlides>0)if(e.settings.infiniteLoop)a=Math.ceil(e.children.length/s());else
// when breakpoint goes above children length, counter is the number of pages
for(
// use a while loop to determine pages
var b=0,c=0;b<e.children.length;)++a,b=c+q(),c+=e.settings.moveSlides<=q()?e.settings.moveSlides:q();else a=Math.ceil(e.children.length/q());return a},s=function(){
// if moveSlides was set by the user and moveSlides is less than number of slides showing
// if moveSlides was set by the user and moveSlides is less than number of slides showing
return e.settings.moveSlides>0&&e.settings.moveSlides<=q()?e.settings.moveSlides:q()},t=function(){
// if last slide, not infinite loop, and number of children is larger than specified maxSlides
if(e.children.length>e.settings.maxSlides&&e.active.last&&!e.settings.infiniteLoop){if("horizontal"==e.settings.mode){
// get the last child's position
var a=e.children.last(),b=a.position();
// set the left position
u(-(b.left-(e.viewport.width()-a.outerWidth())),"reset",0)}else if("vertical"==e.settings.mode){
// get the last showing index's position
var c=e.children.length-e.settings.minSlides,b=e.children.eq(c).position();
// set the top position
u(-b.top,"reset",0)}}else{
// get the position of the first showing slide
var b=e.children.eq(e.active.index*s()).position();
// check for last slide
e.active.index==r()-1&&(e.active.last=!0),
// set the repective position
void 0!=b&&("horizontal"==e.settings.mode?u(-b.left,"reset",0):"vertical"==e.settings.mode&&u(-b.top,"reset",0))}},u=function(a,b,c,d){
// use CSS transform
if(e.usingCSS){
// determine the translate3d value
var g="vertical"==e.settings.mode?"translate3d(0, "+a+"px, 0)":"translate3d("+a+"px, 0, 0)";
// add the CSS transition-duration
f.css("-"+e.cssPrefix+"-transition-duration",c/1e3+"s"),"slide"==b?(
// set the property value
f.css(e.animProp,g),
// bind a callback method - executes when CSS transition completes
f.bind("transitionend webkitTransitionEnd oTransitionEnd MSTransitionEnd",function(){
// unbind the callback
f.unbind("transitionend webkitTransitionEnd oTransitionEnd MSTransitionEnd"),G()})):"reset"==b?f.css(e.animProp,g):"ticker"==b&&(
// make the transition use 'linear'
f.css("-"+e.cssPrefix+"-transition-timing-function","linear"),f.css(e.animProp,g),
// bind a callback method - executes when CSS transition completes
f.bind("transitionend webkitTransitionEnd oTransitionEnd MSTransitionEnd",function(){
// unbind the callback
f.unbind("transitionend webkitTransitionEnd oTransitionEnd MSTransitionEnd"),
// reset the position
u(d.resetValue,"reset",0),
// start the loop again
L()}))}else{var h={};h[e.animProp]=a,"slide"==b?f.animate(h,c,e.settings.easing,function(){G()}):"reset"==b?f.css(e.animProp,a):"ticker"==b&&f.animate(h,speed,"linear",function(){u(d.resetValue,"reset",0),
// run the recursive loop after animation
L()})}},v=function(){
// loop through each pager item
for(var b="",c=r(),d=0;d<c;d++){var f="";
// if a buildPager function is supplied, use it to get pager link value, else use index + 1
e.settings.buildPager&&a.isFunction(e.settings.buildPager)?(f=e.settings.buildPager(d),e.pagerEl.addClass("bx-custom-pager")):(f=d+1,e.pagerEl.addClass("bx-default-pager")),
// var linkContent = slider.settings.buildPager && $.isFunction(slider.settings.buildPager) ? slider.settings.buildPager(i) : i + 1;
// add the markup to the string
b+='<div class="bx-pager-item"><a href="" data-slide-index="'+d+'" class="bx-pager-link">'+f+"</a></div>"}
// populate the pager element with pager links
e.pagerEl.html(b)},w=function(){e.settings.pagerCustom?e.pagerEl=a(e.settings.pagerCustom):(
// create the pager DOM element
e.pagerEl=a('<div class="bx-pager" />'),
// if a pager selector was supplied, populate it with the pager
e.settings.pagerSelector?a(e.settings.pagerSelector).html(e.pagerEl):e.controls.el.addClass("bx-has-pager").append(e.pagerEl),
// populate the pager
v()),
// assign the pager click binding
e.pagerEl.on("click","a",E)},x=function(){/*
			* @edit Replace holders for specified elements
			* @author exwar
			* */
// bind click actions to the controls
// if nextSlector was supplied, populate it
e.settings.nextSelector&&(e.controls.next=a(e.settings.nextSelector)),
// if prevSlector was supplied, populate it
e.settings.prevSelector&&(e.controls.prev=a(e.settings.prevSelector)),e.controls.next.bind("click",A),e.controls.prev.bind("click",B),
// if no custom selectors were supplied
e.settings.nextSelector||e.settings.prevSelector||(
// add the controls to the DOM
e.controls.directionEl=a('<div class="bx-controls-direction" />'),
// add the control elements to the directionEl
e.controls.directionEl.append(e.controls.prev).append(e.controls.next),
// slider.viewport.append(slider.controls.directionEl);
e.controls.el.addClass("bx-has-controls-direction").append(e.controls.directionEl))},y=function(){e.controls.start=a('<div class="bx-controls-auto-item"><a class="bx-start" href="">'+e.settings.startText+"</a></div>"),e.controls.stop=a('<div class="bx-controls-auto-item"><a class="bx-stop" href="">'+e.settings.stopText+"</a></div>"),
// add the controls to the DOM
e.controls.autoEl=a('<div class="bx-controls-auto" />'),
// bind click actions to the controls
e.controls.autoEl.on("click",".bx-start",C),e.controls.autoEl.on("click",".bx-stop",D),
// if autoControlsCombine, insert only the "start" control
e.settings.autoControlsCombine?e.controls.autoEl.append(e.controls.start):e.controls.autoEl.append(e.controls.start).append(e.controls.stop),
// if auto controls selector was supplied, populate it with the controls
e.settings.autoControlsSelector?a(e.settings.autoControlsSelector).html(e.controls.autoEl):e.controls.el.addClass("bx-has-controls-auto").append(e.controls.autoEl),
// update the auto controls
H(e.settings.autoStart?"stop":"start")},z=function(){
// cycle through each child
e.children.each(function(b){
// get the image title attribute
var c=a(this).find("img:first").attr("title");
// append the caption
void 0!=c&&(""+c).length&&a(this).append('<div class="bx-caption"><span>'+c+"</span></div>")})},A=function(a){
// if auto show is running, stop it
e.settings.auto&&f.stopAuto(),f.goToNextSlide(),a.preventDefault()},B=function(a){
// if auto show is running, stop it
e.settings.auto&&f.stopAuto(),f.goToPrevSlide(),a.preventDefault()},C=function(a){f.startAuto(),a.preventDefault()},D=function(a){f.stopAuto(),a.preventDefault()},E=function(b){
// if auto show is running, stop it
e.settings.auto&&f.stopAuto();var c=a(b.currentTarget);if(void 0!==c.attr("data-slide-index")){var d=parseInt(c.attr("data-slide-index"));
// if clicked pager link is not active, continue with the goToSlide call
d!=e.active.index&&f.goToSlide(d),b.preventDefault()}},F=function(b){
// if "short" pager type
var c=e.children.length;// nb of children
if("short"==e.settings.pagerType)return e.settings.maxSlides>1&&(c=Math.ceil(e.children.length/e.settings.maxSlides)),void e.pagerEl.html(b+1+e.settings.pagerShortSeparator+c);
// remove all pager active classes
e.pagerEl.find("a").removeClass("active"),
// apply the active class for all pagers
e.pagerEl.each(function(c,d){a(d).find("a").eq(b).addClass("active")})},G=function(){
// if infinte loop is true
if(e.settings.infiniteLoop){var a="";
// first slide
0==e.active.index?
// set the new position
a=e.children.eq(0).position():e.active.index==r()-1&&e.carousel?a=e.children.eq((r()-1)*s()).position():e.active.index==e.children.length-1&&(a=e.children.eq(e.children.length-1).position()),a&&("horizontal"==e.settings.mode?u(-a.left,"reset",0):"vertical"==e.settings.mode&&u(-a.top,"reset",0))}
// declare that the transition is complete
e.working=!1,
// onSlideAfter callback
e.settings.onSlideAfter(e.children.eq(e.active.index),e.oldIndex,e.active.index)},H=function(a){
// if autoControlsCombine is true, replace the current control with the new state
e.settings.autoControlsCombine?e.controls.autoEl.html(e.controls[a]):(e.controls.autoEl.find("a").removeClass("active"),e.controls.autoEl.find("a:not(.bx-"+a+")").addClass("active"))},I=function(){1==r()?(e.controls.prev.addClass("disabled"),e.controls.next.addClass("disabled")):!e.settings.infiniteLoop&&e.settings.hideControlOnEnd&&(
// if first slide
0==e.active.index?(e.controls.prev.addClass("disabled"),e.controls.next.removeClass("disabled")):e.active.index==r()-1?(e.controls.next.addClass("disabled"),e.controls.prev.removeClass("disabled")):(e.controls.prev.removeClass("disabled"),e.controls.next.removeClass("disabled")))},J=function(){
// if autoDelay was supplied, launch the auto show using a setTimeout() call
if(e.settings.autoDelay>0){setTimeout(f.startAuto,e.settings.autoDelay)}else f.startAuto();
// if autoHover is requested
e.settings.autoHover&&
// on el hover
f.hover(function(){
// if the auto show is currently playing (has an active interval)
e.interval&&(
// stop the auto show and pass true agument which will prevent control update
f.stopAuto(!0),
// create a new autoPaused value which will be used by the relative "mouseout" event
e.autoPaused=!0)},function(){
// if the autoPaused value was created be the prior "mouseover" event
e.autoPaused&&(
// start the auto show and pass true agument which will prevent control update
f.startAuto(!0),
// reset the autoPaused value
e.autoPaused=null)})},K=function(){var b=0;
// if autoDirection is "next", append a clone of the entire slider
if("next"==e.settings.autoDirection)f.append(e.children.clone().addClass("bx-clone"));else{f.prepend(e.children.clone().addClass("bx-clone"));var c=e.children.first().position();b="horizontal"==e.settings.mode?-c.left:-c.top}u(b,"reset",0),
// do not allow controls in ticker mode
e.settings.pager=!1,e.settings.controls=!1,e.settings.autoControls=!1,
// if autoHover is requested
e.settings.tickerHover&&!e.usingCSS&&
// on el hover
e.viewport.hover(function(){f.stop()},function(){
// calculate the total width of children (used to calculate the speed ratio)
var b=0;e.children.each(function(c){b+="horizontal"==e.settings.mode?a(this).outerWidth(!0):a(this).outerHeight(!0)});
// calculate the speed ratio (used to determine the new speed to finish the paused animation)
var c=e.settings.speed/b,d="horizontal"==e.settings.mode?"left":"top";L(c*(b-Math.abs(parseInt(f.css(d)))))}),
// start the ticker loop
L()},L=function(a){speed=a?a:e.settings.speed;var b={left:0,top:0},c={left:0,top:0};
// if "next" animate left position to last child, then reset left to 0
"next"==e.settings.autoDirection?b=f.find(".bx-clone").first().position():c=e.children.first().position();var d="horizontal"==e.settings.mode?-b.left:-b.top,g="horizontal"==e.settings.mode?-c.left:-c.top,h={resetValue:g};u(d,"ticker",speed,h)},M=function(){
// initialize object to contain all touch values
e.touch={start:{x:0,y:0},end:{x:0,y:0}},e.viewport.bind("touchstart",N)},N=function(a){if(e.working)a.preventDefault();else{
// record the original position when touch starts
e.touch.originalPos=f.position();var b=a.originalEvent;
// record the starting touch x, y coordinates
e.touch.start.x=b.changedTouches[0].pageX,e.touch.start.y=b.changedTouches[0].pageY,
// bind a "touchmove" event to the viewport
e.viewport.bind("touchmove",O),
// bind a "touchend" event to the viewport
e.viewport.bind("touchend",P)}},O=function(a){var b=a.originalEvent,c=Math.abs(b.changedTouches[0].pageX-e.touch.start.x),d=Math.abs(b.changedTouches[0].pageY-e.touch.start.y);if(
// x axis swipe
3*c>d&&e.settings.preventDefaultSwipeX?a.preventDefault():3*d>c&&e.settings.preventDefaultSwipeY&&a.preventDefault(),"fade"!=e.settings.mode&&e.settings.oneToOneTouch){var f=0;
// if horizontal, drag along x axis
if("horizontal"==e.settings.mode){var g=b.changedTouches[0].pageX-e.touch.start.x;f=e.touch.originalPos.left+g}else{var g=b.changedTouches[0].pageY-e.touch.start.y;f=e.touch.originalPos.top+g}u(f,"reset",0)}},P=function(a){e.viewport.unbind("touchmove",O);var b=a.originalEvent,c=0;
// if fade mode, check if absolute x distance clears the threshold
if(
// record end x, y positions
e.touch.end.x=b.changedTouches[0].pageX,e.touch.end.y=b.changedTouches[0].pageY,"fade"==e.settings.mode){var d=Math.abs(e.touch.start.x-e.touch.end.x);d>=e.settings.swipeThreshold&&(e.touch.start.x>e.touch.end.x?f.goToNextSlide():f.goToPrevSlide(),f.stopAuto())}else{var d=0;
// calculate distance and el's animate property
"horizontal"==e.settings.mode?(d=e.touch.end.x-e.touch.start.x,c=e.touch.originalPos.left):(d=e.touch.end.y-e.touch.start.y,c=e.touch.originalPos.top),
// if not infinite loop and first / last slide, do not attempt a slide transition
!e.settings.infiniteLoop&&(0==e.active.index&&d>0||e.active.last&&d<0)?u(c,"reset",200):
// check if distance clears threshold
Math.abs(d)>=e.settings.swipeThreshold?(d<0?f.goToNextSlide():f.goToPrevSlide(),f.stopAuto()):
// el.animate(property, 200);
u(c,"reset",200)}e.viewport.unbind("touchend",P)},Q=function(b){
// don't do anything if slider isn't initialized.
if(e.initialized){
// get the new window dimens (again, thank you IE)
var c=a(window).width(),d=a(window).height();
// make sure that it is a true window resize
// *we must check this because our dinosaur friend IE fires a window resize event when certain DOM elements
// are resized. Can you just die already?*
g==c&&h==d||(
// set the new window dimens
g=c,h=d,
// update all dynamic elements
f.redrawSlider(),
// Call user resize handler
e.settings.onSliderResize.call(f,e.active.index))}};
// returns the current jQuery object
/**
		 * ===================================================================================
		 * = PUBLIC FUNCTIONS
		 * ===================================================================================
		 */
/**
		 * Performs slide transition to the specified slide
		 *
		 * @param slideIndex (int)
		 *  - the destination slide's index (zero-based)
		 *
		 * @param direction (string)
		 *  - INTERNAL USE ONLY - the direction of travel ("prev" / "next")
		 */
/**
		 * Transitions to the next slide in the show
		 */
/**
		 * Transitions to the prev slide in the show
		 */
/**
		 * Starts the auto show
		 *
		 * @param preventControlUpdate (boolean)
		 *  - if true, auto controls state will not be updated
		 */
/**
		 * Stops the auto show
		 *
		 * @param preventControlUpdate (boolean)
		 *  - if true, auto controls state will not be updated
		 */
/**
		 * Returns current slide index (zero-based)
		 */
/**
		 * Returns current slide element
		 */
/**
		 * Returns number of slides in show
		 */
/**
		 * Update all dynamic slider elements
		 */
/**
		 * Destroy the current instance of the slider (revert everything back to original state)
		 */
/**
		 * Reload the slider (revert all DOM changes, and re-initialize)
		 */
return f.goToSlide=function(b,c){
// if plugin is currently in motion, ignore request
if(!e.working&&e.active.index!=b)
// if slider is set to mode: "fade"
if(
// declare that plugin is in motion
e.working=!0,
// store the old index
e.oldIndex=e.active.index,
// if slideIndex is less than zero, set active index to last child (this happens during infinite loop)
b<0?e.active.index=r()-1:b>=r()?e.active.index=0:e.active.index=b,
// onSlideBefore, onSlideNext, onSlidePrev callbacks
e.settings.onSlideBefore(e.children.eq(e.active.index),e.oldIndex,e.active.index),"next"==c?e.settings.onSlideNext(e.children.eq(e.active.index),e.oldIndex,e.active.index):"prev"==c&&e.settings.onSlidePrev(e.children.eq(e.active.index),e.oldIndex,e.active.index),
// check if last slide
e.active.last=e.active.index>=r()-1,
// update the pager with active class
e.settings.pager&&F(e.active.index),
// // check for direction control update
e.settings.controls&&I(),"fade"==e.settings.mode)
// if adaptiveHeight is true and next height is different from current height, animate to the new height
e.settings.adaptiveHeight&&e.viewport.height()!=n()&&e.viewport.animate({height:n()},e.settings.adaptiveHeightSpeed),
// fade out the visible child and reset its z-index value
e.children.filter(":visible").fadeOut(e.settings.speed).css({zIndex:0}),
// fade in the newly requested slide
e.children.eq(e.active.index).css("zIndex",e.settings.slideZIndex+1).fadeIn(e.settings.speed,function(){a(this).css("zIndex",e.settings.slideZIndex),G()});else{
// if adaptiveHeight is true and next height is different from current height, animate to the new height
e.settings.adaptiveHeight&&e.viewport.height()!=n()&&e.viewport.animate({height:n()},e.settings.adaptiveHeightSpeed);var d=0,g={left:0,top:0};
// if carousel and not infinite loop
if(!e.settings.infiniteLoop&&e.carousel&&e.active.last)if("horizontal"==e.settings.mode){
// get the last child position
var h=e.children.eq(e.children.length-1);g=h.position(),
// calculate the position of the last slide
d=e.viewport.width()-h.outerWidth()}else{
// get last showing index position
var i=e.children.length-e.settings.minSlides;g=e.children.eq(i).position()}else if(e.carousel&&e.active.last&&"prev"==c){
// get the last child position
var j=1==e.settings.moveSlides?e.settings.maxSlides-s():(r()-1)*s()-(e.children.length-e.settings.maxSlides),h=f.children(".bx-clone").eq(j);g=h.position()}else if("next"==c&&0==e.active.index)
// get the last clone position
g=f.find("> .bx-clone").eq(e.settings.maxSlides).position(),e.active.last=!1;else if(b>=0){var k=b*s();g=e.children.eq(k).position()}/* If the position doesn't exist
				 * (e.g. if you destroy the slider on a next click),
				 * it doesn't throw an error.
				 */
if(void 0!==g){var l="horizontal"==e.settings.mode?-(g.left-d):-g.top;
// plugin values to be animated
u(l,"slide",e.settings.speed)}}},f.goToNextSlide=function(){
// if infiniteLoop is false and last page is showing, disregard call
if(e.settings.infiniteLoop||!e.active.last){var a=parseInt(e.active.index)+1;f.goToSlide(a,"next")}},f.goToPrevSlide=function(){
// if infiniteLoop is false and last page is showing, disregard call
if(e.settings.infiniteLoop||0!=e.active.index){var a=parseInt(e.active.index)-1;f.goToSlide(a,"prev")}},f.startAuto=function(a){
// if an interval already exists, disregard call
e.interval||(
// create an interval
e.interval=setInterval(function(){"next"==e.settings.autoDirection?f.goToNextSlide():f.goToPrevSlide()},e.settings.pause),
// if auto controls are displayed and preventControlUpdate is not true
e.settings.autoControls&&1!=a&&H("stop"))},f.stopAuto=function(a){
// if no interval exists, disregard call
e.interval&&(
// clear the interval
clearInterval(e.interval),e.interval=null,
// if auto controls are displayed and preventControlUpdate is not true
e.settings.autoControls&&1!=a&&H("start"))},f.getCurrentSlide=function(){return e.active.index},f.getCurrentSlideElement=function(){return e.children.eq(e.active.index)},f.getSlideCount=function(){return e.children.length},f.redrawSlider=function(){
// resize all children in ratio to new screen size
e.children.add(f.find(".bx-clone")).width(p()),
// adjust the height
e.viewport.css("height",n()),
// update the slide position
e.settings.ticker||t(),
// if active.last was true before the screen resize, we want
// to keep it last no matter what screen size we end on
e.active.last&&(e.active.index=r()-1),
// if the active index (page) no longer exists due to the resize, simply set the index as last
e.active.index>=r()&&(e.active.last=!0),
// if a pager is being displayed and a custom pager is not being used, update it
e.settings.pager&&!e.settings.pagerCustom&&(v(),F(e.active.index))},f.destroySlider=function(){
// don't do anything if slider has already been destroyed
e.initialized&&(e.initialized=!1,a(".bx-clone",this).remove(),e.children.each(function(){void 0!=a(this).data("origStyle")?a(this).attr("style",a(this).data("origStyle")):a(this).removeAttr("style")}),void 0!=a(this).data("origStyle")?this.attr("style",a(this).data("origStyle")):a(this).removeAttr("style"),a(this).unwrap().unwrap(),e.controls.el&&e.controls.el.remove(),e.controls.next&&e.controls.next.remove(),e.controls.prev&&e.controls.prev.remove(),e.pagerEl&&e.settings.controls&&e.pagerEl.remove(),a(".bx-caption",this).remove(),e.controls.autoEl&&e.controls.autoEl.remove(),clearInterval(e.interval),e.settings.responsive&&a(window).unbind("resize",Q))},f.reloadSlider=function(a){void 0!=a&&(d=a),f.destroySlider(),j()},j(),this}}(jQuery),function(a,b,c,d){
// Strict Mode
"use strict";function e(b,c){
// DOM Context
this.element=b,
// Selections
this.$context=a(b).data("api",this),this.$layers=this.$context.find(".layer");
// Data Extraction
var d={calibrateX:this.$context.data("calibrate-x")||null,calibrateY:this.$context.data("calibrate-y")||null,invertX:this.$context.data("invert-x")||null,invertY:this.$context.data("invert-y")||null,limitX:parseFloat(this.$context.data("limit-x"))||null,limitY:parseFloat(this.$context.data("limit-y"))||null,scalarX:parseFloat(this.$context.data("scalar-x"))||null,scalarY:parseFloat(this.$context.data("scalar-y"))||null,frictionX:parseFloat(this.$context.data("friction-x"))||null,frictionY:parseFloat(this.$context.data("friction-y"))||null,originX:parseFloat(this.$context.data("origin-x"))||null,originY:parseFloat(this.$context.data("origin-y"))||null};
// Delete Null Data Values
for(var e in d)null===d[e]&&delete d[e];
// Compose Settings Object
a.extend(this,g,c,d),
// States
this.calibrationTimer=null,this.calibrationFlag=!0,this.enabled=!1,this.depths=[],this.raf=null,
// Element Bounds
this.bounds=null,this.ex=0,this.ey=0,this.ew=0,this.eh=0,
// Element Center
this.ecx=0,this.ecy=0,
// Element Range
this.erx=0,this.ery=0,
// Calibration
this.cx=0,this.cy=0,
// Input
this.ix=0,this.iy=0,
// Motion
this.mx=0,this.my=0,
// Velocity
this.vx=0,this.vy=0,
// Callbacks
this.onMouseMove=this.onMouseMove.bind(this),this.onDeviceOrientation=this.onDeviceOrientation.bind(this),this.onOrientationTimer=this.onOrientationTimer.bind(this),this.onCalibrationTimer=this.onCalibrationTimer.bind(this),this.onAnimationFrame=this.onAnimationFrame.bind(this),this.onWindowResize=this.onWindowResize.bind(this),
// Initialise
this.initialise()}
// Constants
var f="parallax",g={relativeInput:!1,clipRelativeInput:!1,calibrationThreshold:100,calibrationDelay:500,supportDelay:500,calibrateX:!1,calibrateY:!0,invertX:!0,invertY:!0,limitX:!1,limitY:!1,scalarX:10,scalarY:10,frictionX:.1,frictionY:.1,originX:.5,originY:.5};e.prototype.transformSupport=function(a){for(var d=c.createElement("div"),e=!1,f=null,g=!1,h=null,i=null,j=0,k=this.vendors.length;j<k;j++)if(null!==this.vendors[j]?(h=this.vendors[j][0]+"transform",i=this.vendors[j][1]+"Transform"):(h="transform",i="transform"),void 0!==d.style[i]){e=!0;break}switch(a){case"2D":g=e;break;case"3D":if(e){var l=c.body||c.createElement("body"),m=c.documentElement,n=m.style.overflow;c.body||(m.style.overflow="hidden",m.appendChild(l),l.style.overflow="hidden",l.style.background=""),l.appendChild(d),d.style[i]="translate3d(1px,1px,1px)",f=b.getComputedStyle(d).getPropertyValue(h),g=void 0!==f&&f.length>0&&"none"!==f,m.style.overflow=n,l.removeChild(d)}}return g},e.prototype.ww=null,e.prototype.wh=null,e.prototype.wcx=null,e.prototype.wcy=null,e.prototype.wrx=null,e.prototype.wry=null,e.prototype.portrait=null,e.prototype.desktop=!navigator.userAgent.match(/(iPhone|iPod|iPad|Android|BlackBerry|BB10|mobi|tablet|opera mini|nexus 7)/i),e.prototype.vendors=[null,["-webkit-","webkit"],["-moz-","Moz"],["-o-","O"],["-ms-","ms"]],e.prototype.motionSupport=!!b.DeviceMotionEvent,e.prototype.orientationSupport=!!b.DeviceOrientationEvent,e.prototype.orientationStatus=0,e.prototype.transform2DSupport=e.prototype.transformSupport("2D"),e.prototype.transform3DSupport=e.prototype.transformSupport("3D"),e.prototype.propertyCache={},e.prototype.initialise=function(){
// Configure Styles
"static"===this.$context.css("position")&&this.$context.css({position:"relative"}),
// Hardware Accelerate Context
this.accelerate(this.$context),
// Setup
this.updateLayers(),this.updateDimensions(),this.enable(),this.queueCalibration(this.calibrationDelay)},e.prototype.updateLayers=function(){
// Cache Layer Elements
this.$layers=this.$context.find(".layer"),this.depths=[],
// Configure Layer Styles
this.$layers.css({position:"absolute",display:"block",left:0,top:0}),this.$layers.first().css({position:"relative"}),
// Hardware Accelerate Layers
this.accelerate(this.$layers),
// Cache Depths
this.$layers.each(a.proxy(function(b,c){this.depths.push(a(c).data("depth")||0)},this))},e.prototype.updateDimensions=function(){this.ww=b.innerWidth,this.wh=b.innerHeight,this.wcx=this.ww*this.originX,this.wcy=this.wh*this.originY,this.wrx=Math.max(this.wcx,this.ww-this.wcx),this.wry=Math.max(this.wcy,this.wh-this.wcy)},e.prototype.updateBounds=function(){this.bounds=this.element.getBoundingClientRect(),this.ex=this.bounds.left,this.ey=this.bounds.top,this.ew=this.bounds.width,this.eh=this.bounds.height,this.ecx=this.ew*this.originX,this.ecy=this.eh*this.originY,this.erx=Math.max(this.ecx,this.ew-this.ecx),this.ery=Math.max(this.ecy,this.eh-this.ecy)},e.prototype.queueCalibration=function(a){clearTimeout(this.calibrationTimer),this.calibrationTimer=setTimeout(this.onCalibrationTimer,a)},e.prototype.enable=function(){this.enabled||(this.enabled=!0,this.orientationSupport?(this.portrait=null,b.addEventListener("deviceorientation",this.onDeviceOrientation),setTimeout(this.onOrientationTimer,this.supportDelay)):(this.cx=0,this.cy=0,this.portrait=!1,b.addEventListener("mousemove",this.onMouseMove)),b.addEventListener("resize",this.onWindowResize),this.raf=requestAnimationFrame(this.onAnimationFrame))},e.prototype.disable=function(){this.enabled&&(this.enabled=!1,this.orientationSupport?b.removeEventListener("deviceorientation",this.onDeviceOrientation):b.removeEventListener("mousemove",this.onMouseMove),b.removeEventListener("resize",this.onWindowResize),cancelAnimationFrame(this.raf))},e.prototype.calibrate=function(a,b){this.calibrateX=void 0===a?this.calibrateX:a,this.calibrateY=void 0===b?this.calibrateY:b},e.prototype.invert=function(a,b){this.invertX=void 0===a?this.invertX:a,this.invertY=void 0===b?this.invertY:b},e.prototype.friction=function(a,b){this.frictionX=void 0===a?this.frictionX:a,this.frictionY=void 0===b?this.frictionY:b},e.prototype.scalar=function(a,b){this.scalarX=void 0===a?this.scalarX:a,this.scalarY=void 0===b?this.scalarY:b},e.prototype.limit=function(a,b){this.limitX=void 0===a?this.limitX:a,this.limitY=void 0===b?this.limitY:b},e.prototype.origin=function(a,b){this.originX=void 0===a?this.originX:a,this.originY=void 0===b?this.originY:b},e.prototype.clamp=function(a,b,c){return a=Math.max(a,b),a=Math.min(a,c)},e.prototype.css=function(b,c,d){var e=this.propertyCache[c];if(!e)for(var f=0,g=this.vendors.length;f<g;f++)if(e=null!==this.vendors[f]?a.camelCase(this.vendors[f][1]+"-"+c):c,void 0!==b.style[e]){this.propertyCache[c]=e;break}b.style[e]=d},e.prototype.accelerate=function(a){for(var b=0,c=a.length;b<c;b++){var d=a[b];this.css(d,"transform","translate3d(0,0,0)"),this.css(d,"transform-style","preserve-3d"),this.css(d,"backface-visibility","hidden")}},e.prototype.setPosition=function(a,b,c){b+="px",c+="px",this.transform3DSupport?this.css(a,"transform","translate3d("+b+","+c+",0)"):this.transform2DSupport?this.css(a,"transform","translate("+b+","+c+")"):(a.style.left=b,a.style.top=c)},e.prototype.onOrientationTimer=function(a){this.orientationSupport&&0===this.orientationStatus&&(this.disable(),this.orientationSupport=!1,this.enable())},e.prototype.onCalibrationTimer=function(a){this.calibrationFlag=!0},e.prototype.onWindowResize=function(a){this.updateDimensions()},e.prototype.onAnimationFrame=function(){this.updateBounds();var a=this.ix-this.cx,b=this.iy-this.cy;(Math.abs(a)>this.calibrationThreshold||Math.abs(b)>this.calibrationThreshold)&&this.queueCalibration(0),this.portrait?(this.mx=this.calibrateX?b:this.iy,this.my=this.calibrateY?a:this.ix):(this.mx=this.calibrateX?a:this.ix,this.my=this.calibrateY?b:this.iy),this.mx*=this.ew*(this.scalarX/100),this.my*=this.eh*(this.scalarY/100),isNaN(parseFloat(this.limitX))||(this.mx=this.clamp(this.mx,-this.limitX,this.limitX)),isNaN(parseFloat(this.limitY))||(this.my=this.clamp(this.my,-this.limitY,this.limitY)),this.vx+=(this.mx-this.vx)*this.frictionX,this.vy+=(this.my-this.vy)*this.frictionY;for(var c=0,d=this.$layers.length;c<d;c++){var e=this.depths[c],f=this.$layers[c],g=this.vx*e*(this.invertX?-1:1),h=this.vy*e*(this.invertY?-1:1);this.setPosition(f,g,h)}this.raf=requestAnimationFrame(this.onAnimationFrame)},e.prototype.onDeviceOrientation=function(a){
// Validate environment and event properties.
if(!this.desktop&&null!==a.beta&&null!==a.gamma){
// Set orientation status.
this.orientationStatus=1;
// Extract Rotation
var c=(a.beta||0)/30,d=(a.gamma||0)/30,e=b.innerHeight>b.innerWidth;this.portrait!==e&&(this.portrait=e,this.calibrationFlag=!0),
// Set Calibration
this.calibrationFlag&&(this.calibrationFlag=!1,this.cx=c,this.cy=d),
// Set Input
this.ix=c,this.iy=d}},e.prototype.onMouseMove=function(a){
// Cache mouse coordinates.
var b=a.clientX,c=a.clientY;
// Calculate Mouse Input
!this.orientationSupport&&this.relativeInput?(
// Clip mouse coordinates inside element bounds.
this.clipRelativeInput&&(b=Math.max(b,this.ex),b=Math.min(b,this.ex+this.ew),c=Math.max(c,this.ey),c=Math.min(c,this.ey+this.eh)),
// Calculate input relative to the element.
this.ix=(b-this.ex-this.ecx)/this.erx,this.iy=(c-this.ey-this.ecy)/this.ery):(
// Calculate input relative to the window.
this.ix=(b-this.wcx)/this.wrx,this.iy=(c-this.wcy)/this.wry)};var h={enable:e.prototype.enable,disable:e.prototype.disable,updateLayers:e.prototype.updateLayers,calibrate:e.prototype.calibrate,friction:e.prototype.friction,invert:e.prototype.invert,scalar:e.prototype.scalar,limit:e.prototype.limit,origin:e.prototype.origin};a.fn[f]=function(b){var c=arguments;return this.each(function(){var d=a(this),g=d.data(f);g||(g=new e(this,b),d.data(f,g)),h[b]&&g[b].apply(g,Array.prototype.slice.call(c,1))})}}(window.jQuery||window.Zepto,window,document),function(){for(var a=0,b=["ms","moz","webkit","o"],c=0;c<b.length&&!window.requestAnimationFrame;++c)window.requestAnimationFrame=window[b[c]+"RequestAnimationFrame"],window.cancelAnimationFrame=window[b[c]+"CancelAnimationFrame"]||window[b[c]+"CancelRequestAnimationFrame"];window.requestAnimationFrame||(window.requestAnimationFrame=function(b,c){var d=(new Date).getTime(),e=Math.max(0,16-(d-a)),f=window.setTimeout(function(){b(d+e)},e);return a=d+e,f}),window.cancelAnimationFrame||(window.cancelAnimationFrame=function(a){clearTimeout(a)})}(),RichMarker.prototype=new google.maps.OverlayView,window.RichMarker=RichMarker,/**
 * Returns the current visibility state of the marker.
 *
 * @return {boolean} The visiblity of the marker.
 */
RichMarker.prototype.getVisible=function(){/** @type {boolean} */
return this.get("visible")},RichMarker.prototype.getVisible=RichMarker.prototype.getVisible,/**
 * Sets the visiblility state of the marker.
 *
 * @param {boolean} visible The visiblilty of the marker.
 */
RichMarker.prototype.setVisible=function(a){this.set("visible",a)},RichMarker.prototype.setVisible=RichMarker.prototype.setVisible,/**
 *  The visible changed event.
 */
RichMarker.prototype.visible_changed=function(){this.ready_&&(this.markerWrapper_.style.display=this.getVisible()?"":"none",this.draw())},RichMarker.prototype.visible_changed=RichMarker.prototype.visible_changed,/**
 * Sets the marker to be flat.
 *
 * @param {boolean} flat If the marker is to be flat or not.
 */
RichMarker.prototype.setFlat=function(a){this.set("flat",!!a)},RichMarker.prototype.setFlat=RichMarker.prototype.setFlat,/**
 * If the makrer is flat or not.
 *
 * @return {boolean} True the marker is flat.
 */
RichMarker.prototype.getFlat=function(){/** @type {boolean} */
return this.get("flat")},RichMarker.prototype.getFlat=RichMarker.prototype.getFlat,/**
 * Get the width of the marker.
 *
 * @return {Number} The width of the marker.
 */
RichMarker.prototype.getWidth=function(){/** @type {Number} */
return this.get("width")},RichMarker.prototype.getWidth=RichMarker.prototype.getWidth,/**
 * Get the height of the marker.
 *
 * @return {Number} The height of the marker.
 */
RichMarker.prototype.getHeight=function(){/** @type {Number} */
return this.get("height")},RichMarker.prototype.getHeight=RichMarker.prototype.getHeight,/**
 * Sets the marker's box shadow.
 *
 * @param {string} shadow The box shadow to set.
 */
RichMarker.prototype.setShadow=function(a){this.set("shadow",a),this.flat_changed()},RichMarker.prototype.setShadow=RichMarker.prototype.setShadow,/**
 * Gets the marker's box shadow.
 *
 * @return {string} The box shadow.
 */
RichMarker.prototype.getShadow=function(){/** @type {string} */
return this.get("shadow")},RichMarker.prototype.getShadow=RichMarker.prototype.getShadow,/**
 * Flat changed event.
 */
RichMarker.prototype.flat_changed=function(){this.ready_&&(this.markerWrapper_.style.boxShadow=this.markerWrapper_.style.webkitBoxShadow=this.markerWrapper_.style.MozBoxShadow=this.getFlat()?"":this.getShadow())},RichMarker.prototype.flat_changed=RichMarker.prototype.flat_changed,/**
 * Sets the zIndex of the marker.
 *
 * @param {Number} index The index to set.
 */
RichMarker.prototype.setZIndex=function(a){this.set("zIndex",a)},RichMarker.prototype.setZIndex=RichMarker.prototype.setZIndex,/**
 * Gets the zIndex of the marker.
 *
 * @return {Number} The zIndex of the marker.
 */
RichMarker.prototype.getZIndex=function(){/** @type {Number} */
return this.get("zIndex")},RichMarker.prototype.getZIndex=RichMarker.prototype.getZIndex,/**
 * zIndex changed event.
 */
RichMarker.prototype.zIndex_changed=function(){this.getZIndex()&&this.ready_&&(this.markerWrapper_.style.zIndex=this.getZIndex())},RichMarker.prototype.zIndex_changed=RichMarker.prototype.zIndex_changed,/**
 * Whether the marker is draggable or not.
 *
 * @return {boolean} True if the marker is draggable.
 */
RichMarker.prototype.getDraggable=function(){/** @type {boolean} */
return this.get("draggable")},RichMarker.prototype.getDraggable=RichMarker.prototype.getDraggable,/**
 * Sets the marker to be draggable or not.
 *
 * @param {boolean} draggable If the marker is draggable or not.
 */
RichMarker.prototype.setDraggable=function(a){this.set("draggable",!!a)},RichMarker.prototype.setDraggable=RichMarker.prototype.setDraggable,/**
 * Draggable property changed callback.
 */
RichMarker.prototype.draggable_changed=function(){this.ready_&&(this.getDraggable()?this.addDragging_(this.markerWrapper_):this.removeDragListeners_())},RichMarker.prototype.draggable_changed=RichMarker.prototype.draggable_changed,/**
 * Gets the postiton of the marker.
 *
 * @return {google.maps.LatLng} The position of the marker.
 */
RichMarker.prototype.getPosition=function(){/** @type {google.maps.LatLng} */
return this.get("position")},RichMarker.prototype.getPosition=RichMarker.prototype.getPosition,/**
 * Sets the position of the marker.
 *
 * @param {google.maps.LatLng} position The position to set.
 */
RichMarker.prototype.setPosition=function(a){this.set("position",a)},RichMarker.prototype.setPosition=RichMarker.prototype.setPosition,/**
 * Position changed event.
 */
RichMarker.prototype.position_changed=function(){this.draw()},RichMarker.prototype.position_changed=RichMarker.prototype.position_changed,/**
 * Gets the anchor.
 *
 * @return {google.maps.Size} The position of the anchor.
 */
RichMarker.prototype.getAnchor=function(){/** @type {google.maps.Size} */
return this.get("anchor")},RichMarker.prototype.getAnchor=RichMarker.prototype.getAnchor,/**
 * Sets the anchor.
 *
 * @param {RichMarkerPosition|google.maps.Size} anchor The anchor to set.
 */
RichMarker.prototype.setAnchor=function(a){this.set("anchor",a)},RichMarker.prototype.setAnchor=RichMarker.prototype.setAnchor,/**
 * Anchor changed event.
 */
RichMarker.prototype.anchor_changed=function(){this.draw()},RichMarker.prototype.anchor_changed=RichMarker.prototype.anchor_changed,/**
 * Converts a HTML string to a document fragment.
 *
 * @param {string} htmlString The HTML string to convert.
 * @return {Node} A HTML document fragment.
 * @private
 */
RichMarker.prototype.htmlToDocumentFragment_=function(a){var b=document.createElement("DIV");if(b.innerHTML=a,1==b.childNodes.length)/** @type {!Node} */
return b.removeChild(b.firstChild);for(var c=document.createDocumentFragment();b.firstChild;)c.appendChild(b.firstChild);return c},/**
 * Removes all children from the node.
 *
 * @param {Node} node The node to remove all children from.
 * @private
 */
RichMarker.prototype.removeChildren_=function(a){if(a)for(var b;b=a.firstChild;)a.removeChild(b)},/**
 * Sets the content of the marker.
 *
 * @param {string|Node} content The content to set.
 */
RichMarker.prototype.setContent=function(a){this.set("content",a)},RichMarker.prototype.setContent=RichMarker.prototype.setContent,/**
 * Get the content of the marker.
 *
 * @return {string|Node} The marker content.
 */
RichMarker.prototype.getContent=function(){/** @type {Node|string} */
return this.get("content")},RichMarker.prototype.getContent=RichMarker.prototype.getContent,/**
 * Sets the marker content and adds loading events to images
 */
RichMarker.prototype.content_changed=function(){if(this.markerContent_){this.removeChildren_(this.markerContent_);var a=this.getContent();if(a){"string"==typeof a&&(a=a.replace(/^\s*([\S\s]*)\b\s*$/,"$1"),a=this.htmlToDocumentFragment_(a)),this.markerContent_.appendChild(a);for(var b,c=this,d=this.markerContent_.getElementsByTagName("IMG"),e=0;b=d[e];e++)
// By default, a browser lets a image be dragged outside of the browser,
// so by calling preventDefault we stop this behaviour and allow the image
// to be dragged around the map and now out of the browser and onto the
// desktop.
google.maps.event.addDomListener(b,"mousedown",function(a){c.getDraggable()&&(a.preventDefault&&a.preventDefault(),a.returnValue=!1)}),
// Because we don't know the size of an image till it loads, add a
// listener to the image load so the marker can resize and reposition
// itself to be the correct height.
google.maps.event.addDomListener(b,"load",function(){c.draw()});google.maps.event.trigger(this,"domready")}this.ready_&&this.draw()}},RichMarker.prototype.content_changed=RichMarker.prototype.content_changed,/**
 * Sets the cursor.
 *
 * @param {string} whichCursor What cursor to show.
 * @private
 */
RichMarker.prototype.setCursor_=function(a){if(this.ready_){var b="";navigator.userAgent.indexOf("Gecko/")!==-1?(
// Moz has some nice cursors :)
"dragging"==a&&(b="-moz-grabbing"),"dragready"==a&&(b="-moz-grab"),"draggable"==a&&(b="pointer")):("dragging"!=a&&"dragready"!=a||(b="move"),"draggable"==a&&(b="pointer")),this.markerWrapper_.style.cursor!=b&&(this.markerWrapper_.style.cursor=b)}},/**
 * Start dragging.
 *
 * @param {Event} e The event.
 */
RichMarker.prototype.startDrag=function(a){if(this.getDraggable()&&!this.dragging_){this.dragging_=!0;var b=this.getMap();this.mapDraggable_=b.get("draggable"),b.set("draggable",!1),
// Store the current mouse position
this.mouseX_=a.clientX,this.mouseY_=a.clientY,this.setCursor_("dragready"),
// Stop the text from being selectable while being dragged
this.markerWrapper_.style.MozUserSelect="none",this.markerWrapper_.style.KhtmlUserSelect="none",this.markerWrapper_.style.WebkitUserSelect="none",this.markerWrapper_.unselectable="on",this.markerWrapper_.onselectstart=function(){return!1},this.addDraggingListeners_(),google.maps.event.trigger(this,"dragstart")}},/**
 * Stop dragging.
 */
RichMarker.prototype.stopDrag=function(){this.getDraggable()&&this.dragging_&&(this.dragging_=!1,this.getMap().set("draggable",this.mapDraggable_),this.mouseX_=this.mouseY_=this.mapDraggable_=null,
// Allow the text to be selectable again
this.markerWrapper_.style.MozUserSelect="",this.markerWrapper_.style.KhtmlUserSelect="",this.markerWrapper_.style.WebkitUserSelect="",this.markerWrapper_.unselectable="off",this.markerWrapper_.onselectstart=function(){},this.removeDraggingListeners_(),this.setCursor_("draggable"),google.maps.event.trigger(this,"dragend"),this.draw())},/**
 * Handles the drag event.
 *
 * @param {Event} e The event.
 */
RichMarker.prototype.drag=function(a){if(!this.getDraggable()||!this.dragging_)
// This object isn't draggable or we have stopped dragging
return void this.stopDrag();var b=this.mouseX_-a.clientX,c=this.mouseY_-a.clientY;this.mouseX_=a.clientX,this.mouseY_=a.clientY;var d=parseInt(this.markerWrapper_.style.left,10)-b,e=parseInt(this.markerWrapper_.style.top,10)-c;this.markerWrapper_.style.left=d+"px",this.markerWrapper_.style.top=e+"px";var f=this.getOffset_(),g=new google.maps.Point(d-f.width,e-f.height),h=this.getProjection();this.setPosition(h.fromDivPixelToLatLng(g)),this.setCursor_("dragging"),google.maps.event.trigger(this,"drag")},/**
 * Removes the drag listeners associated with the marker.
 *
 * @private
 */
RichMarker.prototype.removeDragListeners_=function(){this.draggableListener_&&(google.maps.event.removeListener(this.draggableListener_),delete this.draggableListener_),this.setCursor_("")},/**
 * Add dragability events to the marker.
 *
 * @param {Node} node The node to apply dragging to.
 * @private
 */
RichMarker.prototype.addDragging_=function(a){if(a){var b=this;this.draggableListener_=google.maps.event.addDomListener(a,"mousedown",function(a){b.startDrag(a)}),this.setCursor_("draggable")}},/**
 * Add dragging listeners.
 *
 * @private
 */
RichMarker.prototype.addDraggingListeners_=function(){var a=this;this.markerWrapper_.setCapture?(this.markerWrapper_.setCapture(!0),this.draggingListeners_=[google.maps.event.addDomListener(this.markerWrapper_,"mousemove",function(b){a.drag(b)},!0),google.maps.event.addDomListener(this.markerWrapper_,"mouseup",function(){a.stopDrag(),a.markerWrapper_.releaseCapture()},!0)]):this.draggingListeners_=[google.maps.event.addDomListener(window,"mousemove",function(b){a.drag(b)},!0),google.maps.event.addDomListener(window,"mouseup",function(){a.stopDrag()},!0)]},/**
 * Remove dragging listeners.
 *
 * @private
 */
RichMarker.prototype.removeDraggingListeners_=function(){if(this.draggingListeners_){for(var a,b=0;a=this.draggingListeners_[b];b++)google.maps.event.removeListener(a);this.draggingListeners_.length=0}},/**
 * Get the anchor offset.
 *
 * @return {google.maps.Size} The size offset.
 * @private
 */
RichMarker.prototype.getOffset_=function(){var a=this.getAnchor();if("object"==typeof a)/** @type {google.maps.Size} */
return a;var b=new google.maps.Size(0,0);if(!this.markerContent_)return b;var c=this.markerContent_.offsetWidth,d=this.markerContent_.offsetHeight;switch(a){case RichMarkerPosition.TOP_LEFT:break;case RichMarkerPosition.TOP:b.width=-c/2;break;case RichMarkerPosition.TOP_RIGHT:b.width=-c;break;case RichMarkerPosition.LEFT:b.height=-d/2;break;case RichMarkerPosition.MIDDLE:b.width=-c/2,b.height=-d/2;break;case RichMarkerPosition.RIGHT:b.width=-c,b.height=-d/2;break;case RichMarkerPosition.BOTTOM_LEFT:b.height=-d;break;case RichMarkerPosition.BOTTOM:b.width=-c/2,b.height=-d;break;case RichMarkerPosition.BOTTOM_RIGHT:b.width=-c,b.height=-d}return b},/**
 * Adding the marker to a map.
 * Implementing the interface.
 */
RichMarker.prototype.onAdd=function(){if(this.markerWrapper_||(this.markerWrapper_=document.createElement("DIV"),this.markerWrapper_.style.position="absolute"),this.getZIndex()&&(this.markerWrapper_.style.zIndex=this.getZIndex()),this.markerWrapper_.style.display=this.getVisible()?"":"none",!this.markerContent_){this.markerContent_=document.createElement("DIV"),this.markerWrapper_.appendChild(this.markerContent_);var a=this;google.maps.event.addDomListener(this.markerContent_,"click",function(b){google.maps.event.trigger(a,"click")}),google.maps.event.addDomListener(this.markerContent_,"mouseover",function(b){google.maps.event.trigger(a,"mouseover")}),google.maps.event.addDomListener(this.markerContent_,"mouseout",function(b){google.maps.event.trigger(a,"mouseout")})}this.ready_=!0,this.content_changed(),this.flat_changed(),this.draggable_changed();var b=this.getPanes();b&&b.overlayMouseTarget.appendChild(this.markerWrapper_),google.maps.event.trigger(this,"ready")},RichMarker.prototype.onAdd=RichMarker.prototype.onAdd,/**
 * Impelementing the interface.
 */
RichMarker.prototype.draw=function(){if(this.ready_&&!this.dragging_){var a=this.getProjection();if(a){var b=/** @type {google.maps.LatLng} */this.get("position"),c=a.fromLatLngToDivPixel(b),d=this.getOffset_();this.markerWrapper_.style.top=c.y+d.height+"px",this.markerWrapper_.style.left=c.x+d.width+"px";var e=this.markerContent_.offsetHeight,f=this.markerContent_.offsetWidth;f!=this.get("width")&&this.set("width",f),e!=this.get("height")&&this.set("height",e)}}},RichMarker.prototype.draw=RichMarker.prototype.draw,/**
 * Removing a marker from the map.
 * Implementing the interface.
 */
RichMarker.prototype.onRemove=function(){this.markerWrapper_&&this.markerWrapper_.parentNode&&this.markerWrapper_.parentNode.removeChild(this.markerWrapper_),this.removeDragListeners_()},RichMarker.prototype.onRemove=RichMarker.prototype.onRemove;/**
 * RichMarker Anchor positions
 * @enum {number}
 */
var RichMarkerPosition={TOP_LEFT:1,TOP:2,TOP_RIGHT:3,LEFT:4,MIDDLE:5,RIGHT:6,BOTTOM_LEFT:7,BOTTOM:8,BOTTOM_RIGHT:9};window.RichMarkerPosition=RichMarkerPosition;